<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Import Namespace="System" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Runtime.InteropServices" #>

// Copyright (c) 2010 Ananth B.
// All rights reserved.
// 
// The contents of this file are made available under the terms of the
// Eclipse Public License v1.0 (the "License") which accompanies this
// distribution, and is available at the following URL:
// http://www.opensource.org/licenses/eclipse-1.0.php
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for
// the specific language governing rights and limitations under the License.
// 
// By using this software in any fashion, you are agreeing to be bound by the
// terms of the License.
//
// Copyright (C) 2016 Luca Piccioni
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
// USA

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace OpenGL
{
	/// <summary>
	/// Vector interface.
	/// </summary>
	public interface IVector
	{
		/// <summary>
		/// Get the rank of the vector.
		/// </summary>
		int Rank { get; }

		/// <summary>
		/// Vector interface.
		/// </summary>
		int Size { get; }
	}

<# 
	var types = new[] { "sbyte", "byte", "short", "ushort", "int", "uint", "long", "ulong", "float", "double" };
	var typeSizes = new[] { Marshal.SizeOf(typeof(sbyte)), Marshal.SizeOf(typeof(byte)), Marshal.SizeOf(typeof(short)), Marshal.SizeOf(typeof(ushort)), Marshal.SizeOf(typeof(int)), Marshal.SizeOf(typeof(uint)), Marshal.SizeOf(typeof(long)), Marshal.SizeOf(typeof(ulong)), Marshal.SizeOf(typeof(float)), Marshal.SizeOf(typeof(double)) };
	var ranks = new[] { 2, 3, 4, 8, 16 };
	var components = new[] { 
		new[] { "x,s0", "y,s1" },
		new[] { "x,s0", "y,s1", "z,s2" },
		new[] { "x,s0", "y,s1", "z,s2", "w,s3" },
		new[] { "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7" },
		new[] { "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "sa,sA", "sb,sB", "sc,sC", "sd,sD", "se,sE", "sf,sF" }
	};

	System.Diagnostics.Debug.Assert(types.Length == typeSizes.Length);

	for (var t = 0; t < types.Length; t++)
		for (int r = 0; r < ranks.Length; r++) {
			var structName = String.Format("{0}{1}", types[t], ranks[r]);
			var typeName = String.Format("{0}{1}", types[t], ranks[r]);
			var debuggerDisplay = structName + ": " + String.Join(", ", (from cNames in components[r] let c = cNames.Split(',')[0] select c + "={" + c + "}").ToArray());
			var formatString = string.Join(",", from idx in Enumerable.Range(0, components[r].Length) select "{" + idx + "}");
			var values = String.Join(", ", (from cNames in components[r] let c = cNames.Split(',')[0] select c).ToArray());
			
#>
	/// <summary>
	/// Vector of <#= ranks[r]#> <#= types[t]#>.
	/// </summary>
	[StructLayout(LayoutKind.Explicit)]
	[DebuggerDisplay("<#= debuggerDisplay #>")]
	public partial struct <#= string.Format("{0} : {1}", structName, "IVector") #>
	{
		#region Constructors

		/// <summary>
		/// Construct a <#=structName#> with all components equals to the specified value.
		/// </summary>
		/// <param name="v">
		/// A <see cref="<#= types[t] #>"/> that specify the vector's components value.
		/// </param>
		public <#= typeName #>(<#= types[t] #> v)
		{
<#
			for (int v = 0; v < components[r].Length; v++) {
				foreach (var c in components[r][v].Split(',')) {
#>			<#= c #> = <#
				}
				#>v;
<#
		}
#>
		}

<#
		var signature = string.Join(", ", from r0 in Enumerable.Range(0, ranks[r]) select string.Format("{0} {1}", types[t], components[r][r0].Split(',')[0]));
#>

		/// <summary>
		/// Construct a <#=structName#> specifying all vector components.
		/// </summary>
<#
			for (int v = 0; v < components[r].Length; v++) {
#>
		/// <param name="<#= components[r][v].Split(',')[0] #>">
		/// A <see cref="sbyte"/> that specify the <#= v + 1#>th vector's component value.
		/// </param>
<#
			}
#>
		public <#= typeName #>(<#= signature #>)
		{
<#
			for (int v = 0; v < components[r].Length; v++) {
				foreach (var c in components[r][v].Split(',')) {
#>			this.<#= c #> = <# } #><#= components[r][v].Split(',')[0] #>;
<#
			}
#>
		}

		#endregion

		#region Structure

<#
			int offset = 0;
			for (int v = 0; v < components[r].Length; v++) {
				foreach (var c in components[r][v].Split(',')) {
#>
		/// <summary>
		/// The <#= v + 1#>th vector component.
		/// </summary>
		[FieldOffset(<#= offset#>)]
		public <#= types[t]#> <#= c #>;

<#
				}
				offset += typeSizes[t];
			}
#>
		#endregion

		#region Accessor

		/// <summary>
		/// Get or set a vector component.
		/// </summary>
		/// <param name="index">
		/// A <see cref="Int32"/> that specify the component index.
		/// </param>
		/// <returns>
		/// It returns the vector component specified by <paramref name="index"/>.
		/// </returns>
		public <#= types[t] #> this[int index]
		{
			get 
			{
				switch (index) {
<#
						for (int i = 0; i < components[r].Length; i++) {
							var componentName = components[r][i].Split(',')[0];
#>
					case <#= i #>: return (<#= componentName #>);
<#
						}
#>
					default:
						throw new IndexOutOfRangeException();
				}
			}
			set
			{
				switch (index) {
<#
						for (int i = 0; i < components[r].Length; i++) {
							var componentName = components[r][i].Split(',')[0];
#>
					case <#= i #>: <#= componentName #> = value; break;
<#
						}
#>
					default:
						throw new IndexOutOfRangeException();
				}
			}
		}

		#endregion

		#region Object Overrides

		/// <summary>
		/// Get a string representing this <#= typeName #>.
		/// </summary>
		/// <returns>
		/// Returns a <see cref="String"/> that represents this <#= typeName #>.
		/// </returns>
		public override string ToString()
		{
			return String.Format("|<#= formatString #>|", <#= values #>);
		}

		#endregion

		#region IVectorType implementation

		/// <summary>
		/// Get the rank of the vector.
		/// </summary>
		int IVector.Rank { get { return (<#= ranks[r] #>); } }

		/// <summary>
		/// Vector interface.
		/// </summary>
		int IVector.Size { get { return (<#= ranks[r] #> * <#= typeSizes[t] #>); } }

		#endregion
	}

<#
}
#>
}